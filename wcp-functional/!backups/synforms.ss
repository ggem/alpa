;;; Time-stamp: <2000-01-20 02:11:54 kemillik>
;;; (time-stamp generated by emacs:  Type M-x time-stamp anywhere to update)

;;; syncase is a pattern matcher where patterns are quoted or
;;; quasiquoted expressions, or symbols. Unquoted symbols denote
;;; pattern variables.  All quoted things must match precisely. 
;;; Also, there are two symbols ".." and "..." that may be used to allow
;;; repetitions of the preceeding pattern.  Any pattern variables within are
;;; bound to a list of matches.  ".." and "..." may be nested.  Below is the
;;; canonical example of "let"

;;; [`(let ([,vars ,exps] ...) ,body ,bodies ...)
;;;  (guard (andmap symbol? vars) (no-duplicates? vars))
;;;  `((lambda (,@vars) ,body ,@bodies) ,@exps)]

;;; For the pattern to match, the optional guard requires its
;;; arguments to be true.  The guard also uses the pattern
;;; variables.

;;; We have added three obvious new forms: synlambda, synlet, and
;;; synlet*.  Finally, we have added a very useful operation,
;;; make-double-collector-over-list, whose description follows from the
;;; very simple code  below.
;;; Here are some descriptive examples of each of the new special forms.

;;;> (define foo
;;;    (synlambda `((if ,exp0 ,exp1) ,env)
;;;      (guard (number? exp1))
;;;      `(,env (if ,exp0 ,exp1 0))))
;;;> (foo '(if 1 2) 'anenv)
;;;(anenv (if 1 2 0))

;;;> (synlet ([`(if ,exp0 ,exp1)
;;;            (guard (number? exp0))
;;;            '(if 0 1)])
;;;    `(if ,exp1, exp0))
;;;(if 1 0)

;;;> (synlet ([`(if ,x ,y ,z) '(if 1 2 3)]
;;;	      [`(if ,a then ,b else ,c) '(if 1 then 2 else 3)]
;;;	      [`(when ,u ,w) (guard (number? u) (number? w) (= u w))
;;;	       '(when 1 1)])
;;;    (list x y z a b c a b))
;;; (1 2 3 1 2 3 1 2)

;;;> (synlet* ([`(if ,exp0 ,exp1) (guard (number? exp0)) '(if 0 1)]
;;;            [`(if ,x ,y ,exp2) `(if ,exp0 ,exp1 5)])
;;;    `(if ,exp0 ,y ,exp2))
;;;(if 0 1 5)

(define-syntax syncase(syntax-rules()((_ exp(clause ...)...)(let((x exp))(
call/cc(lambda(succeed)(pm:c start x succeed clause ...)...(error'syncase
"No match for ~s"x)))))))(define-syntax pm:c(syntax-rules(guard start finish)((
pm:c start v succ pattern(guard exp ...)body0 body ...)(pm:parse start pattern(
pm:c finish v(when(and exp ...)(call-with-values(lambda()(begin body0 body ...)
)succ)))))((pm:c finish v body pattern usedformals)(pm:find-dup usedformals(
cont(dup)(pm:error"Duplicate patvar ~s in pattern ~s"dup pattern))(cont()(pm v
pattern body))))((_ start v succ pattern body0 body ...)(pm:c start v succ
pattern(guard)body0 body ...))((_ start v succ pattern)(pm:error
"Missing body for pattern ~s"pattern))))(define-syntax pm:parse(syntax-rules(..
quasiquote quote unquote start)((pm:parse start()k)(pm:ak k(null)()))((pm:parse
start,x k)(pm:error"Unquote without quasiquote ~s"x))((pm:parse start`x k)(
pm:parseqq start x k))((pm:parse start'x k)(pm:parseq start x k))((pm:parse
start x k)(pm:ak k(formal x)(x)))))(define-syntax pm:parseqq(lambda(x)(
syntax-case x(.. unquote start dothead dottail dottemps pairhead pairtail)((
pm:parseqq start,()k)(syntax(pm:error"Bad variable: ~s"())))((pm:parseqq start,
`x k)(syntax(pm:parseqq start x k)))((pm:parseqq start,'x k)(syntax(pm:parseq
start x k)))((pm:parseqq start,(x . y)k)(syntax(pm:error"Bad variable: ~s"(x . y
))))((pm:parseqq start,#(x ...)k)(syntax(pm:error"Bad variable: ~s"#(x ...))))(
(pm:parseqq start,x k)(syntax(pm:ak k(formal x)(x))))((pm:parseqq start(x .. . y
)k)(syntax(pm:parseqq start x(pm:parseqq dothead y k))))((pm:parseqq start(x
dots . y)k)(and(identifier?(syntax dots))(free-identifier=?(syntax dots)(syntax
(... ...))))(syntax(pm:parseqq start x(pm:parseqq dothead y k))))((pm:parseqq
dothead y k xpat xformals)(syntax(pm:parseqq^ start y()()(pm:parseqq dottail
xpat xformals k))))((pm:parseqq dottail xpat xformals k yrevpat yformals)(
syntax(pm:gen-temps xformals()(pm:parseqq dottemps xpat yrevpat xformals
yformals k))))((pm:parseqq dottemps xpat yrevpat(xformal ...)(yformal ...)k
xtemps)(syntax(pm:ak k(dots(xformal ...)xtemps xpat yrevpat)(xformal ... yformal
...))))((pm:parseqq start(x . y)k)(syntax(pm:parseqq start x(pm:parseqq pairhead
y k))))((pm:parseqq pairhead y k xpat xformals)(syntax(pm:parseqq start y(
pm:parseqq pairtail xpat xformals k))))((pm:parseqq pairtail xpat(xformal ...)k
ypat(yformal ...))(syntax(pm:ak k(pair xpat ypat)(xformal ... yformal ...))))((
pm:parseqq start x k)(syntax(pm:ak k(keyword x)()))))))(define-syntax pm:parseq
(syntax-rules(start)((pm:parseq start x k)(pm:ak k(keyword x)()))))(
define-syntax pm:parseqq^(lambda(x)(syntax-case x(.. start pairhead)((
pm:parseqq^ start()acc used k)(syntax(pm:ak k acc())))((pm:parseqq^ start(.. . y
)acc used k)(syntax(pm:error
"Illegal continuation of list pattern beyond dots: ~s"y)))((pm:parseqq^ start(
dots . y)acc used k)(and(identifier?(syntax dots))(free-identifier=?(syntax dots
)(syntax(... ...))))(syntax(pm:error
"Illegal continuation of list pattern beyond dots: ~s"y)))((pm:parseqq^ start(x
. y)acc used k)(syntax(pm:parseqq start x(pm:parseqq^ pairhead y acc used k))))
((pm:parseqq^ pairhead y acc(used ...)k xpat(xformal ...))(syntax(pm:parseqq^
start y(xpat . acc)(used ... xformal ...)k)))((pm:parseqq^ start x acc used k)(
syntax(pm:error"Bad pattern ~s"x))))))(define-syntax pm(syntax-rules(keyword
formal dots null pair)((pm v(keyword k)body)(when(eqv? v'k)body))((pm v(formal f
)body)(let((f v))body))((pm v(dots dformals dtemps dpat(postpat ...))body)(when
(list? v)(let((rev(reverse v)))(pm:help rev(postpat ...)dformals dtemps dpat
body))))((pm v(null)body)(when(null? v)body))((pm v(pair p0 p1)body)(when(pair?
v)(let((x(car v))(y(cdr v)))(pm x p0(pm y p1 body)))))))(define-syntax pm:help(
syntax-rules()((pm:help v()(dformal ...)(dtemp ...)dpat body)(let f((ls v)(
dtemp'())...)(if(null? ls)(let((dformal dtemp)...)body)(let((x(car ls))(y(cdr ls
)))(pm x dpat(f y(cons dformal dtemp)...))))))((pm:help v(post0 postpat ...)
dformals dtemps dpat body)(when(pair? v)(let((x(car v))(y(cdr v)))(pm x post0(
pm:help y(postpat ...)dformals dtemps dpat body)))))))(define-syntax pm:error(
syntax-rules()((pm:error x ...)(error'syncase'x ...))))(define-syntax pm:eq?(
syntax-rules()((_ a b sk fk)(let-syntax((f(syntax-rules(b)((f b _sk _fk)(pm:ak
_sk))((f nonb _sk _fk)(pm:ak _fk)))))(f a sk fk)))))(define-syntax pm:member?(
syntax-rules()((pm:member? a()sk fk)(pm:ak fk))((pm:member? a(id0 . ids)sk fk)(
pm:eq? a id0 sk(cont()(pm:member? a ids sk fk))))))(define-syntax pm:find-dup(
syntax-rules()((pm:find-dup()sk fk)(pm:ak fk))((pm:find-dup(x . y)sk fk)(
pm:member? x y(cont()(pm:ak sk x))(cont()(pm:find-dup y sk fk))))))(
define-syntax pm:gen-temps(syntax-rules()((_()acc k)(pm:ak k acc))((_(x . y)acc
k)(pm:gen-temps y(temp . acc)k))))(define-syntax cont(syntax-rules()((_()body)
body)((_(var ...)body exp ...)(let-syntax((f(syntax-rules()((_ var ...)body))))
(f exp ...)))))(define-syntax pm:ak(syntax-rules()((_(x y ...)z ...)(x y ... z
...))))(define-syntax synlambda(syntax-rules(guard)((_ pat(guard g ...)body0
body1 ...)(lambda(x)(syncase x(pat(guard g ...)(begin body0 body1 ...)))))((_
pat body0 body1 ...)(lambda(x)(syncase x(pat(begin body0 body1 ...)))))))(
define-syntax synlet(syntax-rules(guard)((_((pat(guard g)rhs)...)body0 body1 ...
)((synlambda`(,pat ...)(guard(and g ...))body0 body1 ...)`(,rhs ...)))((_((pat
rhs)...)body0 body1 ...)((synlambda`(,pat ...)body0 body1 ...)`(,rhs ...)))((_
stuff ...)(synlet-all-guarded()stuff ...))))(define-syntax synlet-all-guarded(
syntax-rules(guard)((_(x ...)()body0 body1 ...)(synlet(x ...)body0 body1 ...))(
(_(x ...)((pat(guard g0 g1 g2 ...)rhs)decl ...)body0 body1 ...)(
synlet-all-guarded(x ...(pat(guard(and g0 g1 g2 ...))rhs))(decl ...)body0 body1
...))((_(x ...)((pat rhs)decl ...)body0 body1 ...)(synlet-all-guarded(x ...(pat
(guard #t)rhs))(decl ...)body0 body1 ...))((_(x ...)((pat)decl ...)body0 body1
...)(pm:error"synlet missing right-hand-side for pattern: ~s"pat))((_()(decl ...
))(pm:error"synlet missing body"))))(define-syntax synlet*(syntax-rules()((_(
dec)body0 body1 ...)(synlet(dec)body0 body1 ...))((_(dec0 decl ...)body0 body1
...)(synlet(dec0)(synlet*(decl ...)body0 body1 ...)))))(define
make-double-collector-over-list(lambda(constructor1 base1 constructor2 base2)(
letrec((loop42(lambda args(if(not(=(length args)2))(error'syncase
"Invalid rhs expression"))(let((f(car args))(arg(cadr args)))(cond((null? arg)`
(,base1,base2))(else(synlet((`(,x,y)(f(car arg)))(`(,x*,y*)(loop42 f(cdr arg)))
)`(,(constructor1 x x*),(constructor2 y y*)))))))))loop42)))
