(define cost-reverse!
  (let ()
    (define cons^ sa-cons)
    (define (car^ x $store)
      (if (or (eq? x 'unknown)) 'unknown (sa-car x $store)))
    (define (cdr^ x $store)
      (if (or (eq? x 'unknown)) 'unknown (sa-cdr x $store)))
    (define (set-car!^ x y $store)
      (if (or (eq? x 'unknown))
          'unknown
          (sa-set-car! x y $store)))
    (define (set-cdr!^ x y $store)
      (if (or (eq? x 'unknown))
          'unknown
          (sa-set-cdr! x y $store)))
    (define (make-vector^ x y $store)
      (if (or (eq? x 'unknown))
          'unknown
          (sa-make-vector x y $store)))
    (define vector^ sa-vector)
    (define (vector-ref^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-vector-ref x y $store)))
    (define (vector-length^ x $store)
      (if (or (eq? x 'unknown))
          'unknown
          (sa-vector-length x $store)))
    (define (vector-set!^ x y z $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-vector-set! x y z $store)))
    (define (null?^ x $store)
      (if (or (eq? x 'unknown)) 'unknown (sa-null? x $store)))
    (define (eq?^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-eq? x y $store)))
    (define (+^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-+ x y $store)))
    (define (-^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-- x y $store)))
    (define (*^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-* x y $store)))
    (define (quotient^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-quotient x y $store)))
    (define (>^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-> x y $store)))
    (define (<^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-< x y $store)))
    (define (=^ x y $store)
      (if (or (eq? y 'unknown) (eq? x 'unknown))
          'unknown
          (sa-= x y $store)))
    (define (make-list-unknowns size $store)
      (let loop ([ls '()]
                 [$store $store]
                 [size size])
        (if (= size 0)
            (values ls $store)
            (let-values ([(ls $store) (sa-cons 'unknown ls $store)])
              (loop ls $store (- size 1))))))
    (define (reverse! ls $store)
      (let ([$test:21 (null?^ ls $store)])
        (let ([$fresh:21 $test:21])
          (if (unknown? $fresh:21)
              (let-values ([($val:42 $store:42) (values ls $store)])
                (let-values ([($val:43 $store:43)
                              (reverse!-loop '() ls $store)])
                  (values (lub $val:42 $val:43) (lub $store:42 $store:43))))
              (if $fresh:21
                  (values ls $store)
                  (reverse!-loop '() ls $store))))))
    (define (cost-reverse! ls $store)
      (let ([$test:21 (null?^ ls $store)])
        (let ([$fresh:21 $test:21])
          (if (unknown? $fresh:21)
              (cmax '#(0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 5 1 1 0)
                (c+ '#(0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 5 1 1 1)
                  (cost-reverse!-loop '() ls $store)))
              (if $fresh:21
                  '#(0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 5 1 1 0)
                (c+ '#(0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 5 1 1 1)
                  (cost-reverse!-loop '() ls $store)))))))
    (define (reverse!-loop prev curr $store)
      (let ([next (cdr^ curr $store)])
        (let ([$store (set-cdr!^ curr prev $store)])
          (let ([$test:22 (null?^ next $store)])
            (let ([$fresh:22 $test:22])
              (if (unknown? $fresh:22)
                  (let-values ([($val:44 $store:44) (values curr $store)])
                    (let-values ([($val:45 $store:45)
                                  (reverse!-loop curr next $store)])
                      (values (lub $val:44 $val:45) (lub $store:44 $store:45))))
                  (if $fresh:22
                      (values curr $store)
                      (reverse!-loop curr next $store))))))))
    (define (cost-reverse!-loop prev curr $store)
      (let ([next (cdr^ curr $store)])
        (let ([$store (set-cdr!^ curr prev $store)])
          (let ([$test:22 (null?^ next $store)])
            (let ([$fresh:22 $test:22])
              (if (unknown? $fresh:22)
                  (cmax '#(0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 10 1 3 0)
                    (c+ '#(0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 11 1 3 1)
                      (cost-reverse!-loop curr next $store)))
                  (if $fresh:22
                      '#(0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 10 1 3 0)
                    (c+ '#(0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 11 1 3 1)
                      (cost-reverse!-loop curr next $store)))))))))
    (lambda (size0)
      (let ([$store (store:new)])
        (let-values ([(list-size0 $store) (make-list-unknowns size0 $store)])
          (let-values ()
            (cost-vector->exp
              (c+ '#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1)
                (cost-reverse! list-size0 $store)))))))))
